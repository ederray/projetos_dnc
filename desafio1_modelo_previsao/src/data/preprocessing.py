"""Fun√ß√µes de tratamento dos dados"""
import logging
import holidays
from pandas import DataFrame, Series
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt


def amostra_dados(df: DataFrame) -> DataFrame:
    """Fun√ß√£o para retornar a amostragem dos dados"""
    return df.sample(3)


def remover_duplicados(df: DataFrame, coluna: str) -> DataFrame:
    """Fun√ß√£o para remo√ß√£o de valores duplicados."""
    df.drop_duplicates(subset=[coluna], keep='first', inplace=True)
    return df


def selecao_colunas(df: DataFrame, colunas: list) -> DataFrame:
    """Fun√ß√£o que seleciona as colunas para montagem do dataset"""
    return df[colunas]


def agrupar_dados(df: DataFrame, colunas: list, agr) -> DataFrame:
    """Fun√ß√£o que agrupa as colunas para montagem do dataset."""
    df = df.groupby(by=colunas).agg(agr)
    return df

def media_movel(df: DataFrame, coluna: str, p: list[int]) -> DataFrame:
    """Fun√ß√£o que gera coluna de m√©dia m√≥vel"""
    # verifica o comprimento da lista para seguir o processo.
    if len(p) > 1:
        for valor in p:
            df[f'{coluna}_rm_{valor}'] = df[coluna].rolling(valor).mean()
    else:
        df[f'{coluna}_rm_{p}'] = df[coluna].rolling(p).mean()
    return df


def lag_data(df: DataFrame, coluna: str, lag: list[int]) -> DataFrame:
    """Fun√ß√£o que gera coluna de lags"""
    # verifica o comprimento da lista para seguir o processo.
    if len(lag) > 1:
        for valor in lag:
            df[f'{coluna}_lag_{valor}'] = df[coluna].shift(valor)
    else:
        df[f'{coluna}_lag_{lag}'] = df[coluna].shift(lag)
    return df

def dados_temporais(df: DataFrame) -> DataFrame:
    """Fun√ß√£o que insere colunas com dados temporais a partir do index do Dataframe"""
    df['Dia_Semana'] = df.index.day
    df['M√™s'] = df.index.month

    # cria√ß√£o do objeto com os feriados brasileiros
    br_holidays = holidays.BR()
    df['Feriado'] = df.index.to_series().apply(lambda x: x in br_holidays)

    return df

def grafico_decomposicao_temporal(df: DataFrame, target: str, n: int):
    """Fun√ß√£o para constru√ß√£o de uma decomposi√ß√£o de s√©rie temporal."""
    decomposicao = seasonal_decompose(df[target], model='additive', period=n)
    decomposicao.plot()
    plt.tight_layout()
    return plt.show()

def testar_estacionariedade(serie, nome="S√©rie"):
    """Fun√ß√£o para an√°lise de estacionriedade da s√©rie de dados"""
    resultado = adfuller(serie.dropna())
    print(f"\nüîç Teste ADF - {nome}")
    print(f"ADF Statistic: {resultado[0]:.4f}")
    print(f"p-value: {resultado[1]:.4f}")
    for k, v in resultado[4].items():
        print(f"Crit√©rio {k}%: {v:.4f}")
    
    if resultado[1] < 0.05:
        print("‚úÖ S√©rie estacion√°ria (rejeita H‚ÇÄ)")
    else:
        print("‚ö†Ô∏è S√©rie N√ÉO estacion√°ria (n√£o rejeita H‚ÇÄ)")

def autocorrelacao_lags(serie, max_lag:int, titulo='Autocorrela√ß√£o of Lags', retornar=False):
    """
    Calcula a autocorrela√ß√£o de uma s√©rie temporal para diferentes lags, com logging e gr√°fico.

    Par√¢metros:
    - serie: pd.Series com √≠ndice temporal.
    - max_lag: n√∫mero m√°ximo de lags a considerar.
    - titulo: t√≠tulo do gr√°fico gerado.
    - retornar: se True, retorna um dicion√°rio {lag: correla√ß√£o}

    Retorno:
    - dicion√°rio {lag: correla√ß√£o} se retornar=True
    """
    logging.info(f'Calculando autocorrela√ß√£o de lags at√© {max_lag}')
    resultados = {}

    for lag in range(1, max_lag + 1):
        corr = serie.autocorr(lag=lag)
        resultados[lag] = corr
        logging.debug(f'Lag {lag}: Correlation = {corr:.4f}')

    # Exibe o gr√°fico
    plt.figure(figsize=(10, 4))
    plt.plot(list(resultados.keys()), list(resultados.values()), marker='o')
    plt.title(titulo)
    plt.xlabel('Lag')
    plt.ylabel('Autocorrelation')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    logging.info('Autocorrela√ß√£o plotada com sucesso.')

    if retornar:
        return resultados


def grafico_acf(coluna_target:Series, n_lag:int):
    """Fun√ß√£o para gerar o gr√°fico de autocorrela√ß√£o"""
    plot_acf(coluna_target, lags=n_lag, title=f'Autocorrela√ß√£o de {n_lag}lags') 
    return plt.show()


def grafico_pacf(coluna_target:Series, n_lag:int, metodo:str='ywm'):
    """Fun√ß√£o para gerar o gr√°fico de autocorrela√ß√£o parcial."""
    plot_pacf(coluna_target, lags=n_lag, method=metodo)  # m√©todo est√°vel para s√©ries reais
    return plt.show()